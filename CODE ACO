import numpy as np
import networkx as nx

print("Libraries imported: numpy and networkx.")

# Load the .npz file
data = np.load('/content/metabolic_graph.npz')
print("Metabolic graph data loaded from /content/metabolic_graph.npz.")

# Inspect the contents of the loaded .npz file
print("\nContents of the .npz file:")
for key in data.files:
    print(f"Key: {key}, Shape: {data[key].shape}, Type: {data[key].dtype}")                                                            Dist_matrix = data['Dist']
coords = data['coords']


G = nx.from_numpy_array(Dist_matrix)


for i, (x, y) in enumerate(coords):
    G.nodes[i]['pos'] = (x, y)

print(f"NetworkX graph created with {G.number_of_nodes()} nodes and {G.number_of_edges()} edges.")


print("\nFirst 5 nodes and their attributes:")
for i in range(min(5, G.number_of_nodes())):
    print(f"Node {i}: {G.nodes[i]}")

print("\nFirst 5 edges and their weights:")
for i, (u, v, data) in enumerate(G.edges(data=True)):
    if i >= 5:
        break
    print(f"Edge ({u}, {v}), Weight: {data['weight']:.2f}")                                                                                    num_ants = 20
num_iterations = 100
alpha = 1.0  # Pheromone influence
beta = 2.0   # Heuristic influence (inverse of edge weight)
rho = 0.5    # Pheromone evaporation rate
q = 100.0    # Pheromone deposit factor
initial_pheromone = 0.1 # Initial pheromone level on all edges

print(f"ACO parameters set:\nnum_ants: {num_ants}\nnum_iterations: {num_iterations}\nalpha: {alpha}\nbeta: {beta}\nrho: {rho}\nq: {q}\ninitial_pheromone: {initial_pheromone}")                                          def initialize_pheromones(graph, initial_pheromone):
    """Initializes pheromone trails on all edges of the graph."""
    pheromones = nx.to_numpy_array(graph, weight=None) # Create a matrix of the same shape as adjacency
    pheromones.fill(initial_pheromone) 
    pheromones_dict = {}
    for u, v in graph.edges():
        # Use a tuple (u,v) as key for pheromone value. Ensure consistency (u,v) vs (v,u)
        # For undirected graph, we can store (min(u,v), max(u,v))
        key = tuple(sorted((u, v)))
        pheromones_dict[key] = initial_pheromone

    print(f"Pheromone trails initialized with a value of {initial_pheromone} on {len(pheromones_dict)} edges.")
    return pheromones_dict

# Initialize pheromones for our graph G
pheromone_trails = initialize_pheromones(G, initial_pheromone)
print(f"Type of pheromone_trails: {type(pheromone_trails)}")
print(f"Number of pheromone trails initialized: {len(pheromone_trails)}")
def ant_path_construction(graph, start_node, end_node, pheromone_trails, alpha, beta):
    """An ant constructs a path from start_node to end_node."""
    current_node = start_node
    path = [current_node]
    path_cost = 0
    visited = {current_node}

    while current_node != end_node:
        possible_next_nodes = []
        probabilities = []

        for neighbor in graph.neighbors(current_node):
            if neighbor not in visited:
                possible_next_nodes.append(neighbor)

        if not possible_next_nodes: # If no unvisited neighbors, ant is trapped, break
            path_cost = float('inf') # Mark path as invalid
            break

        total_probability = 0.0
        for next_node in possible_next_nodes:
            edge_key = tuple(sorted((current_node, next_node)))
            pheromone = pheromone_trails.get(edge_key, initial_pheromone) # Use initial_pheromone if edge not in dict
            
            weight = graph[current_node][next_node]['weight']
            if weight == 0: # Avoid division by zero, treat as very favorable path
                heuristic = float('inf')
            elif np.isinf(weight): # Treat infinite weight as impossible to traverse
                heuristic = 0.0
            else:
                heuristic = 1.0 / weight
            
            # Calculate desirability
            desirability = (pheromone**alpha) * (heuristic**beta)
            probabilities.append(desirability)
            total_probability += desirability

        if total_probability == 0.0: # If all probabilities are zero, ant is trapped
            path_cost = float('inf')
            break

        # Normalize probabilities
        probabilities = [p / total_probability for p in probabilities]

        
        next_node = np.random.choice(possible_next_nodes, p=probabilities)

        # Update path and cost
        path_cost += graph[current_node][next_node]['weight']
        path.append(next_node)
        visited.add(next_node)
        current_node = next_node

    return path, path_cost

print("Function 'ant_path_construction' implemented.")
def update_pheromones(pheromone_trails, all_ant_paths, rho, q):
    """Updates pheromone trails based on ant paths and evaporation."""
    # Evaporation
    for edge_key in pheromone_trails.keys():
        pheromone_trails[edge_key] *= (1 - rho)

    # Deposition
    for path, path_cost in all_ant_paths:
        if path_cost != float('inf'): # Only deposit pheromone on valid paths
            # Calculate pheromone deposit amount. Lower cost paths should deposit more pheromone.
            pheromone_deposit = q / path_cost
            for i in range(len(path) - 1):
                u, v = path[i], path[i+1]
                edge_key = tuple(sorted((u, v)))
                pheromone_trails[edge_key] += pheromone_deposit

    print(f"Pheromone trails updated. Evaporation rate: {rho}, Pheromone deposit factor: {q}.")
    return pheromone_trails

print("Function 'update_pheromones' implemented.")                                                                                                                         start_node = 0
end_node = 19


best_path = []
min_cost = float('inf')


convergence_costs = []

print(f"Starting ACO search from node {start_node} to node {end_node}...")

# Main ACO loop
for iteration in range(num_iterations):
    all_ant_paths = []
    for ant in range(num_ants):
        path, cost = ant_path_construction(G, start_node, end_node, pheromone_trails, alpha, beta)
        all_ant_paths.append((path, cost))

        if cost < min_cost:
            min_cost = cost
            best_path = path

    pheromone_trails = update_pheromones(pheromone_trails, all_ant_paths, rho, q)
    convergence_costs.append(min_cost) # Store the current best cost

    if (iteration + 1) % 10 == 0 or iteration == num_iterations - 1:
        print(f"Iteration {iteration + 1}/{num_iterations}: Current best path cost = {min_cost:.2f}")

print("\nACO algorithm finished.")
print(f"Best path found: {best_path}")
print(f"Minimum cost of best path: {min_cost:.2f}")                                                                                                                               import matplotlib.pyplot as plt

print("matplotlib.pyplot imported as plt.")

pos = nx.get_node_attributes(G, 'pos')


plt.figure(figsize=(12, 10))
ax = plt.gca() # Get current axes for drawing


nx.draw_networkx_nodes(G, pos, node_color='lightgrey', node_size=300, ax=ax)


nx.draw_networkx_edges(G, pos, edge_color='gray', alpha=0.5, ax=ax)



path_nodes = best_path
path_node_colors = ['red' if node == start_node or node == end_node else 'blue' for node in path_nodes]
nx.draw_networkx_nodes(G, pos, nodelist=path_nodes, node_color=path_node_colors, node_size=400, ax=ax)


path_edges = []
for i in range(len(best_path) - 1):
    path_edges.append((best_path[i], best_path[i+1]))
nx.draw_networkx_edges(G, pos, edgelist=path_edges, edge_color='red', width=2, ax=ax)

nx.draw_networkx_labels(G, pos, font_size=8, font_color='black', ax=ax)

from matplotlib.patches import Patch
legend_elements = [
    Patch(facecolor='lightgrey', edgecolor='black', label='Other Nodes'),
    Patch(facecolor='red', edgecolor='black', label='Start/End Node'),
    Patch(facecolor='blue', edgecolor='black', label='Path Nodes'),
    Patch(edgecolor='gray', facecolor='none', linewidth=1, label='Other Edges'),
    Patch(edgecolor='red', facecolor='none', linewidth=2, label='Path Edges')
]
ax.legend(handles=legend_elements, loc='upper left', bbox_to_anchor=(1, 1))


plt.title(f'Metabolic Graph with ACO-Found Minimum Cost Path\nStart: {start_node}, End: {end_node}, Cost: {min_cost:.2f}')
plt.axis('off') # Turn off the axis

plt.tight_layout()
plt.show()   
